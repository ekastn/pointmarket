// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: assignment.sql

package gen

import (
	"context"
	"database/sql"
	"encoding/json"
	"time"
)

const createAssignment = `-- name: CreateAssignment :execresult

INSERT INTO assignments (
    title, description, course_id, reward_points, due_date, status
) VALUES (
    ?, ?, ?, ?, ?, ?
)
`

type CreateAssignmentParams struct {
	Title        string                `json:"title"`
	Description  sql.NullString        `json:"description"`
	CourseID     int64                 `json:"course_id"`
	RewardPoints int32                 `json:"reward_points"`
	DueDate      sql.NullTime          `json:"due_date"`
	Status       NullAssignmentsStatus `json:"status"`
}

// Assignments --
func (q *Queries) CreateAssignment(ctx context.Context, arg CreateAssignmentParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createAssignment,
		arg.Title,
		arg.Description,
		arg.CourseID,
		arg.RewardPoints,
		arg.DueDate,
		arg.Status,
	)
}

const createStudentAssignment = `-- name: CreateStudentAssignment :execresult

INSERT INTO student_assignments (
    student_id, assignment_id, status, submission
) VALUES (
    (SELECT student_id FROM students WHERE user_id = ?), ?, ?, ?
)
`

type CreateStudentAssignmentParams struct {
	UserID       int64                        `json:"user_id"`
	AssignmentID int64                        `json:"assignment_id"`
	Status       NullStudentAssignmentsStatus `json:"status"`
	Submission   sql.NullString               `json:"submission"`
}

// Student Assignments --
func (q *Queries) CreateStudentAssignment(ctx context.Context, arg CreateStudentAssignmentParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createStudentAssignment,
		arg.UserID,
		arg.AssignmentID,
		arg.Status,
		arg.Submission,
	)
}

const deleteAssignment = `-- name: DeleteAssignment :exec
DELETE FROM assignments
WHERE id = ?
`

func (q *Queries) DeleteAssignment(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteAssignment, id)
	return err
}

const deleteStudentAssignment = `-- name: DeleteStudentAssignment :exec
DELETE FROM student_assignments
WHERE id = ?
`

func (q *Queries) DeleteStudentAssignment(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteStudentAssignment, id)
	return err
}

const getAssignmentByCourseIDAndOwnerID = `-- name: GetAssignmentByCourseIDAndOwnerID :one
SELECT a.id, a.title, a.description, a.course_id, a.reward_points, a.due_date, a.status, a.created_at, a.updated_at FROM assignments a
JOIN courses c ON a.course_id = c.id
WHERE a.id = ? AND c.owner_id = ?
`

type GetAssignmentByCourseIDAndOwnerIDParams struct {
	ID      int64 `json:"id"`
	OwnerID int64 `json:"owner_id"`
}

func (q *Queries) GetAssignmentByCourseIDAndOwnerID(ctx context.Context, arg GetAssignmentByCourseIDAndOwnerIDParams) (Assignment, error) {
	row := q.db.QueryRowContext(ctx, getAssignmentByCourseIDAndOwnerID, arg.ID, arg.OwnerID)
	var i Assignment
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.CourseID,
		&i.RewardPoints,
		&i.DueDate,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getAssignmentByID = `-- name: GetAssignmentByID :one
SELECT id, title, description, course_id, reward_points, due_date, status, created_at, updated_at FROM assignments
WHERE id = ?
`

func (q *Queries) GetAssignmentByID(ctx context.Context, id int64) (Assignment, error) {
	row := q.db.QueryRowContext(ctx, getAssignmentByID, id)
	var i Assignment
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.CourseID,
		&i.RewardPoints,
		&i.DueDate,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getAssignments = `-- name: GetAssignments :many
SELECT a.id, a.title, a.description, a.course_id, a.reward_points, a.due_date, a.status, a.created_at, a.updated_at, c.title as course_title FROM assignments a JOIN courses c ON a.course_id = c.id
ORDER BY a.created_at DESC
`

type GetAssignmentsRow struct {
	ID           int64                 `json:"id"`
	Title        string                `json:"title"`
	Description  sql.NullString        `json:"description"`
	CourseID     int64                 `json:"course_id"`
	RewardPoints int32                 `json:"reward_points"`
	DueDate      sql.NullTime          `json:"due_date"`
	Status       NullAssignmentsStatus `json:"status"`
	CreatedAt    time.Time             `json:"created_at"`
	UpdatedAt    time.Time             `json:"updated_at"`
	CourseTitle  string                `json:"course_title"`
}

func (q *Queries) GetAssignments(ctx context.Context) ([]GetAssignmentsRow, error) {
	rows, err := q.db.QueryContext(ctx, getAssignments)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAssignmentsRow
	for rows.Next() {
		var i GetAssignmentsRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.CourseID,
			&i.RewardPoints,
			&i.DueDate,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CourseTitle,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAssignmentsByCourseID = `-- name: GetAssignmentsByCourseID :many
SELECT a.id, a.title, a.description, a.course_id, a.reward_points, a.due_date, a.status, a.created_at, a.updated_at, c.title as course_title FROM assignments a JOIN courses c ON a.course_id = c.id
WHERE a.course_id = ?
ORDER BY a.created_at DESC
`

type GetAssignmentsByCourseIDRow struct {
	ID           int64                 `json:"id"`
	Title        string                `json:"title"`
	Description  sql.NullString        `json:"description"`
	CourseID     int64                 `json:"course_id"`
	RewardPoints int32                 `json:"reward_points"`
	DueDate      sql.NullTime          `json:"due_date"`
	Status       NullAssignmentsStatus `json:"status"`
	CreatedAt    time.Time             `json:"created_at"`
	UpdatedAt    time.Time             `json:"updated_at"`
	CourseTitle  string                `json:"course_title"`
}

func (q *Queries) GetAssignmentsByCourseID(ctx context.Context, courseID int64) ([]GetAssignmentsByCourseIDRow, error) {
	rows, err := q.db.QueryContext(ctx, getAssignmentsByCourseID, courseID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAssignmentsByCourseIDRow
	for rows.Next() {
		var i GetAssignmentsByCourseIDRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.CourseID,
			&i.RewardPoints,
			&i.DueDate,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CourseTitle,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAssignmentsByOwnerID = `-- name: GetAssignmentsByOwnerID :many
SELECT a.id, a.title, a.description, a.course_id, a.reward_points, a.due_date, a.status, a.created_at, a.updated_at, c.title as course_title FROM assignments a
JOIN courses c ON a.course_id = c.id
WHERE c.owner_id = ?
ORDER BY a.created_at DESC
`

type GetAssignmentsByOwnerIDRow struct {
	ID           int64                 `json:"id"`
	Title        string                `json:"title"`
	Description  sql.NullString        `json:"description"`
	CourseID     int64                 `json:"course_id"`
	RewardPoints int32                 `json:"reward_points"`
	DueDate      sql.NullTime          `json:"due_date"`
	Status       NullAssignmentsStatus `json:"status"`
	CreatedAt    time.Time             `json:"created_at"`
	UpdatedAt    time.Time             `json:"updated_at"`
	CourseTitle  string                `json:"course_title"`
}

func (q *Queries) GetAssignmentsByOwnerID(ctx context.Context, ownerID int64) ([]GetAssignmentsByOwnerIDRow, error) {
	rows, err := q.db.QueryContext(ctx, getAssignmentsByOwnerID, ownerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAssignmentsByOwnerIDRow
	for rows.Next() {
		var i GetAssignmentsByOwnerIDRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.CourseID,
			&i.RewardPoints,
			&i.DueDate,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CourseTitle,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStudentAssignmentByID = `-- name: GetStudentAssignmentByID :one
SELECT id, student_id, assignment_id, status, score, submission, submitted_at, graded_at, created_at, updated_at,
       attempt, feedback, grader_user_id, COALESCE(attachments, JSON_ARRAY()) AS attachments
FROM student_assignments
WHERE id = ?
`

func (q *Queries) GetStudentAssignmentByID(ctx context.Context, id int64) (StudentAssignment, error) {
	row := q.db.QueryRowContext(ctx, getStudentAssignmentByID, id)
	var i StudentAssignment
	err := row.Scan(
		&i.ID,
		&i.StudentID,
		&i.AssignmentID,
		&i.Status,
		&i.Score,
		&i.Submission,
		&i.SubmittedAt,
		&i.GradedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Attempt,
		&i.Feedback,
		&i.GraderUserID,
		&i.Attachments,
	)
	return i, err
}

const getStudentAssignmentByIDs = `-- name: GetStudentAssignmentByIDs :one
SELECT id, student_id, assignment_id, status, score, submission, submitted_at, graded_at, created_at, updated_at,
       attempt, feedback, grader_user_id, COALESCE(attachments, JSON_ARRAY()) AS attachments
FROM student_assignments
WHERE student_id = (SELECT student_id FROM students WHERE user_id = ?) AND assignment_id = ?
`

type GetStudentAssignmentByIDsParams struct {
	UserID       int64 `json:"user_id"`
	AssignmentID int64 `json:"assignment_id"`
}

func (q *Queries) GetStudentAssignmentByIDs(ctx context.Context, arg GetStudentAssignmentByIDsParams) (StudentAssignment, error) {
	row := q.db.QueryRowContext(ctx, getStudentAssignmentByIDs, arg.UserID, arg.AssignmentID)
	var i StudentAssignment
	err := row.Scan(
		&i.ID,
		&i.StudentID,
		&i.AssignmentID,
		&i.Status,
		&i.Score,
		&i.Submission,
		&i.SubmittedAt,
		&i.GradedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Attempt,
		&i.Feedback,
		&i.GraderUserID,
		&i.Attachments,
	)
	return i, err
}

const getStudentAssignmentsByAssignmentID = `-- name: GetStudentAssignmentsByAssignmentID :many
SELECT sa.id, sa.student_id, sa.assignment_id, sa.status, sa.attempt, sa.score, sa.submission, sa.feedback, sa.submitted_at, sa.graded_at, sa.grader_user_id,
       COALESCE(sa.attachments, JSON_ARRAY()) AS attachments, sa.created_at, sa.updated_at,
       u.display_name AS student_name, u.email AS student_email
FROM student_assignments sa
JOIN students s ON sa.student_id = s.student_id
JOIN users u ON s.user_id = u.id
WHERE sa.assignment_id = ?
ORDER BY sa.created_at DESC
`

type GetStudentAssignmentsByAssignmentIDRow struct {
	ID           int64                        `json:"id"`
	StudentID    string                       `json:"student_id"`
	AssignmentID int64                        `json:"assignment_id"`
	Status       NullStudentAssignmentsStatus `json:"status"`
	Attempt      int32                        `json:"attempt"`
	Score        *float64                     `json:"score"`
	Submission   sql.NullString               `json:"submission"`
	Feedback     sql.NullString               `json:"feedback"`
	SubmittedAt  sql.NullTime                 `json:"submitted_at"`
	GradedAt     sql.NullTime                 `json:"graded_at"`
	GraderUserID sql.NullInt64                `json:"grader_user_id"`
	Attachments  json.RawMessage              `json:"attachments"`
	CreatedAt    sql.NullTime                 `json:"created_at"`
	UpdatedAt    sql.NullTime                 `json:"updated_at"`
	StudentName  string                       `json:"student_name"`
	StudentEmail string                       `json:"student_email"`
}

func (q *Queries) GetStudentAssignmentsByAssignmentID(ctx context.Context, assignmentID int64) ([]GetStudentAssignmentsByAssignmentIDRow, error) {
	rows, err := q.db.QueryContext(ctx, getStudentAssignmentsByAssignmentID, assignmentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetStudentAssignmentsByAssignmentIDRow
	for rows.Next() {
		var i GetStudentAssignmentsByAssignmentIDRow
		if err := rows.Scan(
			&i.ID,
			&i.StudentID,
			&i.AssignmentID,
			&i.Status,
			&i.Attempt,
			&i.Score,
			&i.Submission,
			&i.Feedback,
			&i.SubmittedAt,
			&i.GradedAt,
			&i.GraderUserID,
			&i.Attachments,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.StudentName,
			&i.StudentEmail,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStudentAssignmentsByStudentID = `-- name: GetStudentAssignmentsByStudentID :many
SELECT sa.id, sa.student_id, sa.assignment_id, sa.status, sa.attempt, sa.score, sa.submission, sa.feedback, sa.submitted_at, sa.graded_at, sa.grader_user_id,
       COALESCE(sa.attachments, JSON_ARRAY()) AS attachments, sa.created_at, sa.updated_at,
       a.title AS assignment_title, a.description AS assignment_description, a.course_id AS assignment_course_id, a.reward_points AS assignment_reward_points, a.due_date AS assignment_due_date
FROM student_assignments sa
JOIN assignments a ON sa.assignment_id = a.id
WHERE sa.student_id = (SELECT student_id FROM students WHERE user_id = ?)
ORDER BY sa.created_at DESC
`

type GetStudentAssignmentsByStudentIDRow struct {
	ID                     int64                        `json:"id"`
	StudentID              string                       `json:"student_id"`
	AssignmentID           int64                        `json:"assignment_id"`
	Status                 NullStudentAssignmentsStatus `json:"status"`
	Attempt                int32                        `json:"attempt"`
	Score                  *float64                     `json:"score"`
	Submission             sql.NullString               `json:"submission"`
	Feedback               sql.NullString               `json:"feedback"`
	SubmittedAt            sql.NullTime                 `json:"submitted_at"`
	GradedAt               sql.NullTime                 `json:"graded_at"`
	GraderUserID           sql.NullInt64                `json:"grader_user_id"`
	Attachments            json.RawMessage              `json:"attachments"`
	CreatedAt              sql.NullTime                 `json:"created_at"`
	UpdatedAt              sql.NullTime                 `json:"updated_at"`
	AssignmentTitle        string                       `json:"assignment_title"`
	AssignmentDescription  sql.NullString               `json:"assignment_description"`
	AssignmentCourseID     int64                        `json:"assignment_course_id"`
	AssignmentRewardPoints int32                        `json:"assignment_reward_points"`
	AssignmentDueDate      sql.NullTime                 `json:"assignment_due_date"`
}

func (q *Queries) GetStudentAssignmentsByStudentID(ctx context.Context, userID int64) ([]GetStudentAssignmentsByStudentIDRow, error) {
	rows, err := q.db.QueryContext(ctx, getStudentAssignmentsByStudentID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetStudentAssignmentsByStudentIDRow
	for rows.Next() {
		var i GetStudentAssignmentsByStudentIDRow
		if err := rows.Scan(
			&i.ID,
			&i.StudentID,
			&i.AssignmentID,
			&i.Status,
			&i.Attempt,
			&i.Score,
			&i.Submission,
			&i.Feedback,
			&i.SubmittedAt,
			&i.GradedAt,
			&i.GraderUserID,
			&i.Attachments,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.AssignmentTitle,
			&i.AssignmentDescription,
			&i.AssignmentCourseID,
			&i.AssignmentRewardPoints,
			&i.AssignmentDueDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateAssignment = `-- name: UpdateAssignment :exec
UPDATE assignments
SET
    title = ?,
    description = ?,
    course_id = ?,
    reward_points = ?,
    due_date = ?,
    status = ?
WHERE id = ?
`

type UpdateAssignmentParams struct {
	Title        string                `json:"title"`
	Description  sql.NullString        `json:"description"`
	CourseID     int64                 `json:"course_id"`
	RewardPoints int32                 `json:"reward_points"`
	DueDate      sql.NullTime          `json:"due_date"`
	Status       NullAssignmentsStatus `json:"status"`
	ID           int64                 `json:"id"`
}

func (q *Queries) UpdateAssignment(ctx context.Context, arg UpdateAssignmentParams) error {
	_, err := q.db.ExecContext(ctx, updateAssignment,
		arg.Title,
		arg.Description,
		arg.CourseID,
		arg.RewardPoints,
		arg.DueDate,
		arg.Status,
		arg.ID,
	)
	return err
}

const updateStudentAssignment = `-- name: UpdateStudentAssignment :exec
UPDATE student_assignments
SET
    status = ?,
    score = ?,
    submission = ?,
    feedback = ?,
    submitted_at = ?,
    graded_at = ?,
    grader_user_id = ?
WHERE id = ?
`

type UpdateStudentAssignmentParams struct {
	Status       NullStudentAssignmentsStatus `json:"status"`
	Score        *float64                     `json:"score"`
	Submission   sql.NullString               `json:"submission"`
	Feedback     sql.NullString               `json:"feedback"`
	SubmittedAt  sql.NullTime                 `json:"submitted_at"`
	GradedAt     sql.NullTime                 `json:"graded_at"`
	GraderUserID sql.NullInt64                `json:"grader_user_id"`
	ID           int64                        `json:"id"`
}

func (q *Queries) UpdateStudentAssignment(ctx context.Context, arg UpdateStudentAssignmentParams) error {
	_, err := q.db.ExecContext(ctx, updateStudentAssignment,
		arg.Status,
		arg.Score,
		arg.Submission,
		arg.Feedback,
		arg.SubmittedAt,
		arg.GradedAt,
		arg.GraderUserID,
		arg.ID,
	)
	return err
}
