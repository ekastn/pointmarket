// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: course.sql

package gen

import (
	"context"
	"database/sql"
	"encoding/json"
	"time"
)

const countCourses = `-- name: CountCourses :one
SELECT count(*) FROM courses
`

func (q *Queries) CountCourses(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countCourses)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countCoursesByOwnerID = `-- name: CountCoursesByOwnerID :one
SELECT count(*) FROM courses
WHERE owner_id = ?
`

func (q *Queries) CountCoursesByOwnerID(ctx context.Context, ownerID int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, countCoursesByOwnerID, ownerID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countCoursesWithEnrollmentStatus = `-- name: CountCoursesWithEnrollmentStatus :one
SELECT
    COUNT(c.id)
FROM courses AS c
WHERE
    (c.title LIKE CONCAT('%', ?, '%') OR
     c.description LIKE CONCAT('%', ?, '%'))
    OR ? = ''
`

type CountCoursesWithEnrollmentStatusParams struct {
	Search interface{} `json:"search"`
}

func (q *Queries) CountCoursesWithEnrollmentStatus(ctx context.Context, arg CountCoursesWithEnrollmentStatusParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countCoursesWithEnrollmentStatus, arg.Search, arg.Search, arg.Search)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countCoursesWithOwnershipStatus = `-- name: CountCoursesWithOwnershipStatus :one
SELECT
    COUNT(c.id)
FROM courses AS c
WHERE
    (c.title LIKE CONCAT('%', ?, '%') OR
     c.description LIKE CONCAT('%', ?, '%'))
    OR ? = ''
`

type CountCoursesWithOwnershipStatusParams struct {
	Search interface{} `json:"search"`
}

func (q *Queries) CountCoursesWithOwnershipStatus(ctx context.Context, arg CountCoursesWithOwnershipStatusParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countCoursesWithOwnershipStatus, arg.Search, arg.Search, arg.Search)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createCourse = `-- name: CreateCourse :execresult
INSERT INTO courses (
    title, slug, description, owner_id, metadata
) VALUES (
    ?, ?, ?, ?, ?
)
`

type CreateCourseParams struct {
	Title       string          `json:"title"`
	Slug        string          `json:"slug"`
	Description sql.NullString  `json:"description"`
	OwnerID     int64           `json:"owner_id"`
	Metadata    json.RawMessage `json:"metadata"`
}

func (q *Queries) CreateCourse(ctx context.Context, arg CreateCourseParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createCourse,
		arg.Title,
		arg.Slug,
		arg.Description,
		arg.OwnerID,
		arg.Metadata,
	)
}

const deleteCourse = `-- name: DeleteCourse :exec
DELETE FROM courses
WHERE id = ?
`

func (q *Queries) DeleteCourse(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteCourse, id)
	return err
}

const enrollStudentInCourse = `-- name: EnrollStudentInCourse :execresult

INSERT INTO student_courses (
    student_id, course_id
) VALUES (
    (SELECT student_id FROM students WHERE user_id = ?), ?
)
`

type EnrollStudentInCourseParams struct {
	UserID   int64 `json:"user_id"`
	CourseID int64 `json:"course_id"`
}

// Student Enrollment --
func (q *Queries) EnrollStudentInCourse(ctx context.Context, arg EnrollStudentInCourseParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, enrollStudentInCourse, arg.UserID, arg.CourseID)
}

const getCourseByID = `-- name: GetCourseByID :one
SELECT id, title, slug, description, owner_id, metadata, created_at, updated_at FROM courses
WHERE id = ?
`

func (q *Queries) GetCourseByID(ctx context.Context, id int64) (Course, error) {
	row := q.db.QueryRowContext(ctx, getCourseByID, id)
	var i Course
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Slug,
		&i.Description,
		&i.OwnerID,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCourseBySlug = `-- name: GetCourseBySlug :one
SELECT id, title, slug, description, owner_id, metadata, created_at, updated_at FROM courses
WHERE slug = ?
LIMIT 1
`

func (q *Queries) GetCourseBySlug(ctx context.Context, slug string) (Course, error) {
	row := q.db.QueryRowContext(ctx, getCourseBySlug, slug)
	var i Course
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Slug,
		&i.Description,
		&i.OwnerID,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCourses = `-- name: GetCourses :many
SELECT id, title, slug, description, owner_id, metadata, created_at, updated_at FROM courses
ORDER BY created_at DESC
LIMIT ? OFFSET ?
`

type GetCoursesParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) GetCourses(ctx context.Context, arg GetCoursesParams) ([]Course, error) {
	rows, err := q.db.QueryContext(ctx, getCourses, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Course
	for rows.Next() {
		var i Course
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Slug,
			&i.Description,
			&i.OwnerID,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCoursesByOwnerID = `-- name: GetCoursesByOwnerID :many
SELECT id, title, slug, description, owner_id, metadata, created_at, updated_at FROM courses
WHERE owner_id = ?
ORDER BY created_at DESC
LIMIT ? OFFSET ?
`

type GetCoursesByOwnerIDParams struct {
	OwnerID int64 `json:"owner_id"`
	Limit   int32 `json:"limit"`
	Offset  int32 `json:"offset"`
}

func (q *Queries) GetCoursesByOwnerID(ctx context.Context, arg GetCoursesByOwnerIDParams) ([]Course, error) {
	rows, err := q.db.QueryContext(ctx, getCoursesByOwnerID, arg.OwnerID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Course
	for rows.Next() {
		var i Course
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Slug,
			&i.Description,
			&i.OwnerID,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCoursesWithEnrollmentStatus = `-- name: GetCoursesWithEnrollmentStatus :many
SELECT
    c.id, c.title, c.slug, c.description, c.owner_id, c.metadata, c.created_at, c.updated_at,
    CASE WHEN sc.student_id IS NOT NULL THEN TRUE ELSE FALSE END AS is_enrolled
FROM courses AS c
LEFT JOIN student_courses AS sc ON c.id = sc.course_id AND sc.student_id = (SELECT student_id FROM students WHERE user_id = ?)
WHERE
    (c.title LIKE CONCAT('%', ?, '%') OR
     c.description LIKE CONCAT('%', ?, '%'))
    OR ? = '' -- If search is empty, return all
ORDER BY c.created_at DESC
LIMIT ? OFFSET ?
`

type GetCoursesWithEnrollmentStatusParams struct {
	UserID int64       `json:"user_id"`
	Search interface{} `json:"search"`
	Limit  int32       `json:"limit"`
	Offset int32       `json:"offset"`
}

type GetCoursesWithEnrollmentStatusRow struct {
	ID          int64           `json:"id"`
	Title       string          `json:"title"`
	Slug        string          `json:"slug"`
	Description sql.NullString  `json:"description"`
	OwnerID     int64           `json:"owner_id"`
	Metadata    json.RawMessage `json:"metadata"`
	CreatedAt   time.Time       `json:"created_at"`
	UpdatedAt   time.Time       `json:"updated_at"`
	IsEnrolled  int32           `json:"is_enrolled"`
}

func (q *Queries) GetCoursesWithEnrollmentStatus(ctx context.Context, arg GetCoursesWithEnrollmentStatusParams) ([]GetCoursesWithEnrollmentStatusRow, error) {
	rows, err := q.db.QueryContext(ctx, getCoursesWithEnrollmentStatus,
		arg.UserID,
		arg.Search,
		arg.Search,
		arg.Search,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCoursesWithEnrollmentStatusRow
	for rows.Next() {
		var i GetCoursesWithEnrollmentStatusRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Slug,
			&i.Description,
			&i.OwnerID,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.IsEnrolled,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCoursesWithOwnershipStatus = `-- name: GetCoursesWithOwnershipStatus :many
SELECT
    c.id, c.title, c.slug, c.description, c.owner_id, c.metadata, c.created_at, c.updated_at,
    CASE WHEN c.owner_id = ? THEN TRUE ELSE FALSE END AS is_owner
FROM courses AS c
WHERE
    (c.title LIKE CONCAT('%', ?, '%') OR
     c.description LIKE CONCAT('%', ?, '%'))
    OR ? = ''
ORDER BY c.created_at DESC
LIMIT ? OFFSET ?
`

type GetCoursesWithOwnershipStatusParams struct {
	UserID int64       `json:"user_id"`
	Search interface{} `json:"search"`
	Limit  int32       `json:"limit"`
	Offset int32       `json:"offset"`
}

type GetCoursesWithOwnershipStatusRow struct {
	ID          int64           `json:"id"`
	Title       string          `json:"title"`
	Slug        string          `json:"slug"`
	Description sql.NullString  `json:"description"`
	OwnerID     int64           `json:"owner_id"`
	Metadata    json.RawMessage `json:"metadata"`
	CreatedAt   time.Time       `json:"created_at"`
	UpdatedAt   time.Time       `json:"updated_at"`
	IsOwner     int32           `json:"is_owner"`
}

func (q *Queries) GetCoursesWithOwnershipStatus(ctx context.Context, arg GetCoursesWithOwnershipStatusParams) ([]GetCoursesWithOwnershipStatusRow, error) {
	rows, err := q.db.QueryContext(ctx, getCoursesWithOwnershipStatus,
		arg.UserID,
		arg.Search,
		arg.Search,
		arg.Search,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCoursesWithOwnershipStatusRow
	for rows.Next() {
		var i GetCoursesWithOwnershipStatusRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Slug,
			&i.Description,
			&i.OwnerID,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.IsOwner,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStudentCoursesByUserID = `-- name: GetStudentCoursesByUserID :many
SELECT
    sc.student_id,
    sc.course_id,
    sc.enrolled_at,
    c.title AS course_title,
    c.slug AS course_slug,
    c.description AS course_description,
    c.owner_id AS course_owner_id,
    c.metadata AS course_metadata
FROM student_courses sc
JOIN courses c ON sc.course_id = c.id
WHERE sc.student_id = (SELECT student_id FROM students WHERE user_id = ?)
ORDER BY c.title ASC
`

type GetStudentCoursesByUserIDRow struct {
	StudentID         string          `json:"student_id"`
	CourseID          int64           `json:"course_id"`
	EnrolledAt        time.Time       `json:"enrolled_at"`
	CourseTitle       string          `json:"course_title"`
	CourseSlug        string          `json:"course_slug"`
	CourseDescription sql.NullString  `json:"course_description"`
	CourseOwnerID     int64           `json:"course_owner_id"`
	CourseMetadata    json.RawMessage `json:"course_metadata"`
}

func (q *Queries) GetStudentCoursesByUserID(ctx context.Context, userID int64) ([]GetStudentCoursesByUserIDRow, error) {
	rows, err := q.db.QueryContext(ctx, getStudentCoursesByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetStudentCoursesByUserIDRow
	for rows.Next() {
		var i GetStudentCoursesByUserIDRow
		if err := rows.Scan(
			&i.StudentID,
			&i.CourseID,
			&i.EnrolledAt,
			&i.CourseTitle,
			&i.CourseSlug,
			&i.CourseDescription,
			&i.CourseOwnerID,
			&i.CourseMetadata,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const unenrollStudentFromCourse = `-- name: UnenrollStudentFromCourse :exec
DELETE FROM student_courses
WHERE student_id = (SELECT student_id FROM students WHERE user_id = ?) AND course_id = ?
`

type UnenrollStudentFromCourseParams struct {
	UserID   int64 `json:"user_id"`
	CourseID int64 `json:"course_id"`
}

func (q *Queries) UnenrollStudentFromCourse(ctx context.Context, arg UnenrollStudentFromCourseParams) error {
	_, err := q.db.ExecContext(ctx, unenrollStudentFromCourse, arg.UserID, arg.CourseID)
	return err
}

const updateCourse = `-- name: UpdateCourse :exec
UPDATE courses
SET
    title = ?,
    slug = ?,
    description = ?,
    metadata = ?
WHERE id = ?
`

type UpdateCourseParams struct {
	Title       string          `json:"title"`
	Slug        string          `json:"slug"`
	Description sql.NullString  `json:"description"`
	Metadata    json.RawMessage `json:"metadata"`
	ID          int64           `json:"id"`
}

func (q *Queries) UpdateCourse(ctx context.Context, arg UpdateCourseParams) error {
	_, err := q.db.ExecContext(ctx, updateCourse,
		arg.Title,
		arg.Slug,
		arg.Description,
		arg.Metadata,
		arg.ID,
	)
	return err
}
