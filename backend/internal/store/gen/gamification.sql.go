// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: gamification.sql

package gen

import (
	"context"
	"database/sql"
	"encoding/json"
	"time"
)

const awardBadgeToUser = `-- name: AwardBadgeToUser :execresult

INSERT INTO user_badges (
    user_id, badge_id
) VALUES (
    ?, ?
)
`

type AwardBadgeToUserParams struct {
	UserID  int64 `json:"user_id"`
	BadgeID int64 `json:"badge_id"`
}

// User Badges --
func (q *Queries) AwardBadgeToUser(ctx context.Context, arg AwardBadgeToUserParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, awardBadgeToUser, arg.UserID, arg.BadgeID)
}

const countBadges = `-- name: CountBadges :one
SELECT count(*) FROM badges
`

func (q *Queries) CountBadges(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countBadges)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createBadge = `-- name: CreateBadge :execresult

INSERT INTO badges (
    title, description, criteria, repeatable
) VALUES (
    ?, ?, ?, ?
)
`

type CreateBadgeParams struct {
	Title       string          `json:"title"`
	Description sql.NullString  `json:"description"`
	Criteria    json.RawMessage `json:"criteria"`
	Repeatable  bool            `json:"repeatable"`
}

// Badges --
func (q *Queries) CreateBadge(ctx context.Context, arg CreateBadgeParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createBadge,
		arg.Title,
		arg.Description,
		arg.Criteria,
		arg.Repeatable,
	)
}

const createMission = `-- name: CreateMission :execresult

INSERT INTO missions (
    title, description, reward_points, metadata
) VALUES (
    ?, ?, ?, ?
)
`

type CreateMissionParams struct {
	Title        string          `json:"title"`
	Description  sql.NullString  `json:"description"`
	RewardPoints sql.NullInt32   `json:"reward_points"`
	Metadata     json.RawMessage `json:"metadata"`
}

// Missions --
func (q *Queries) CreateMission(ctx context.Context, arg CreateMissionParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createMission,
		arg.Title,
		arg.Description,
		arg.RewardPoints,
		arg.Metadata,
	)
}

const createUserMission = `-- name: CreateUserMission :execresult

INSERT INTO user_missions (
    mission_id, user_id, status, started_at, progress
) VALUES (
    ?, ?, ?, ?, ?
)
`

type CreateUserMissionParams struct {
	MissionID int64           `json:"mission_id"`
	UserID    int64           `json:"user_id"`
	Status    string          `json:"status"`
	StartedAt time.Time       `json:"started_at"`
	Progress  json.RawMessage `json:"progress"`
}

// User Missions --
func (q *Queries) CreateUserMission(ctx context.Context, arg CreateUserMissionParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createUserMission,
		arg.MissionID,
		arg.UserID,
		arg.Status,
		arg.StartedAt,
		arg.Progress,
	)
}

const deleteBadge = `-- name: DeleteBadge :exec
DELETE FROM badges
WHERE id = ?
`

func (q *Queries) DeleteBadge(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteBadge, id)
	return err
}

const deleteMission = `-- name: DeleteMission :exec
DELETE FROM missions
WHERE id = ?
`

func (q *Queries) DeleteMission(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteMission, id)
	return err
}

const deleteUserMission = `-- name: DeleteUserMission :exec
DELETE FROM user_missions
WHERE id = ?
`

func (q *Queries) DeleteUserMission(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteUserMission, id)
	return err
}

const getBadgeByID = `-- name: GetBadgeByID :one
SELECT id, title, description, criteria, repeatable, created_at FROM badges
WHERE id = ?
`

func (q *Queries) GetBadgeByID(ctx context.Context, id int64) (Badge, error) {
	row := q.db.QueryRowContext(ctx, getBadgeByID, id)
	var i Badge
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.Criteria,
		&i.Repeatable,
		&i.CreatedAt,
	)
	return i, err
}

const getBadges = `-- name: GetBadges :many
SELECT id, title, description, criteria, repeatable, created_at FROM badges
ORDER BY created_at DESC
LIMIT ? OFFSET ?
`

type GetBadgesParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) GetBadges(ctx context.Context, arg GetBadgesParams) ([]Badge, error) {
	rows, err := q.db.QueryContext(ctx, getBadges, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Badge
	for rows.Next() {
		var i Badge
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.Criteria,
			&i.Repeatable,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMissionByID = `-- name: GetMissionByID :one
SELECT id, title, description, reward_points, metadata, created_at, updated_at FROM missions
WHERE id = ?
`

func (q *Queries) GetMissionByID(ctx context.Context, id int64) (Mission, error) {
	row := q.db.QueryRowContext(ctx, getMissionByID, id)
	var i Mission
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.RewardPoints,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getMissions = `-- name: GetMissions :many
SELECT id, title, description, reward_points, metadata, created_at, updated_at FROM missions
ORDER BY created_at DESC
`

func (q *Queries) GetMissions(ctx context.Context) ([]Mission, error) {
	rows, err := q.db.QueryContext(ctx, getMissions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Mission
	for rows.Next() {
		var i Mission
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.RewardPoints,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserBadgesByUserID = `-- name: GetUserBadgesByUserID :many
SELECT ub.user_id, ub.badge_id, ub.awarded_at, b.title, b.description, b.criteria, b.repeatable
FROM user_badges ub
JOIN badges b ON ub.badge_id = b.id
WHERE ub.user_id = ?
ORDER BY ub.awarded_at DESC
`

type GetUserBadgesByUserIDRow struct {
	UserID      int64           `json:"user_id"`
	BadgeID     int64           `json:"badge_id"`
	AwardedAt   time.Time       `json:"awarded_at"`
	Title       string          `json:"title"`
	Description sql.NullString  `json:"description"`
	Criteria    json.RawMessage `json:"criteria"`
	Repeatable  bool            `json:"repeatable"`
}

func (q *Queries) GetUserBadgesByUserID(ctx context.Context, userID int64) ([]GetUserBadgesByUserIDRow, error) {
	rows, err := q.db.QueryContext(ctx, getUserBadgesByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserBadgesByUserIDRow
	for rows.Next() {
		var i GetUserBadgesByUserIDRow
		if err := rows.Scan(
			&i.UserID,
			&i.BadgeID,
			&i.AwardedAt,
			&i.Title,
			&i.Description,
			&i.Criteria,
			&i.Repeatable,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserMissionsByUserID = `-- name: GetUserMissionsByUserID :many
SELECT um.id, um.mission_id, um.user_id, um.status, um.started_at, um.completed_at, um.progress, m.title, m.description, m.reward_points, m.metadata
FROM user_missions um
JOIN missions m ON um.mission_id = m.id
WHERE um.user_id = ?
ORDER BY um.started_at DESC
`

type GetUserMissionsByUserIDRow struct {
	ID           int64           `json:"id"`
	MissionID    int64           `json:"mission_id"`
	UserID       int64           `json:"user_id"`
	Status       string          `json:"status"`
	StartedAt    time.Time       `json:"started_at"`
	CompletedAt  sql.NullTime    `json:"completed_at"`
	Progress     json.RawMessage `json:"progress"`
	Title        string          `json:"title"`
	Description  sql.NullString  `json:"description"`
	RewardPoints sql.NullInt32   `json:"reward_points"`
	Metadata     json.RawMessage `json:"metadata"`
}

func (q *Queries) GetUserMissionsByUserID(ctx context.Context, userID int64) ([]GetUserMissionsByUserIDRow, error) {
	rows, err := q.db.QueryContext(ctx, getUserMissionsByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserMissionsByUserIDRow
	for rows.Next() {
		var i GetUserMissionsByUserIDRow
		if err := rows.Scan(
			&i.ID,
			&i.MissionID,
			&i.UserID,
			&i.Status,
			&i.StartedAt,
			&i.CompletedAt,
			&i.Progress,
			&i.Title,
			&i.Description,
			&i.RewardPoints,
			&i.Metadata,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const revokeBadgeFromUser = `-- name: RevokeBadgeFromUser :exec
DELETE FROM user_badges
WHERE user_id = ? AND badge_id = ?
`

type RevokeBadgeFromUserParams struct {
	UserID  int64 `json:"user_id"`
	BadgeID int64 `json:"badge_id"`
}

func (q *Queries) RevokeBadgeFromUser(ctx context.Context, arg RevokeBadgeFromUserParams) error {
	_, err := q.db.ExecContext(ctx, revokeBadgeFromUser, arg.UserID, arg.BadgeID)
	return err
}

const updateBadge = `-- name: UpdateBadge :exec
UPDATE badges
SET
    title = ?,
    description = ?,
    criteria = ?,
    repeatable = ?
WHERE id = ?
`

type UpdateBadgeParams struct {
	Title       string          `json:"title"`
	Description sql.NullString  `json:"description"`
	Criteria    json.RawMessage `json:"criteria"`
	Repeatable  bool            `json:"repeatable"`
	ID          int64           `json:"id"`
}

func (q *Queries) UpdateBadge(ctx context.Context, arg UpdateBadgeParams) error {
	_, err := q.db.ExecContext(ctx, updateBadge,
		arg.Title,
		arg.Description,
		arg.Criteria,
		arg.Repeatable,
		arg.ID,
	)
	return err
}

const updateMission = `-- name: UpdateMission :exec
UPDATE missions
SET
    title = ?,
    description = ?,
    reward_points = ?,
    metadata = ?
WHERE id = ?
`

type UpdateMissionParams struct {
	Title        string          `json:"title"`
	Description  sql.NullString  `json:"description"`
	RewardPoints sql.NullInt32   `json:"reward_points"`
	Metadata     json.RawMessage `json:"metadata"`
	ID           int64           `json:"id"`
}

func (q *Queries) UpdateMission(ctx context.Context, arg UpdateMissionParams) error {
	_, err := q.db.ExecContext(ctx, updateMission,
		arg.Title,
		arg.Description,
		arg.RewardPoints,
		arg.Metadata,
		arg.ID,
	)
	return err
}

const updateUserMissionStatus = `-- name: UpdateUserMissionStatus :exec
UPDATE user_missions
SET
    status = ?,
    completed_at = ? -- Set to current timestamp if status is 'completed'
WHERE id = ?
`

type UpdateUserMissionStatusParams struct {
	Status      string       `json:"status"`
	CompletedAt sql.NullTime `json:"completed_at"`
	ID          int64        `json:"id"`
}

func (q *Queries) UpdateUserMissionStatus(ctx context.Context, arg UpdateUserMissionStatusParams) error {
	_, err := q.db.ExecContext(ctx, updateUserMissionStatus, arg.Status, arg.CompletedAt, arg.ID)
	return err
}
