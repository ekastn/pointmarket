// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: gamification.sql

package gen

import (
	"context"
	"database/sql"
	"encoding/json"
	"time"
)

const awardBadgeToUser = `-- name: AwardBadgeToUser :execresult

INSERT INTO user_badges (
    user_id, badge_id
) VALUES (
    ?, ?
)
`

type AwardBadgeToUserParams struct {
	UserID  int64 `json:"user_id"`
	BadgeID int64 `json:"badge_id"`
}

// User Badges --
func (q *Queries) AwardBadgeToUser(ctx context.Context, arg AwardBadgeToUserParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, awardBadgeToUser, arg.UserID, arg.BadgeID)
}

const countAllUserBadges = `-- name: CountAllUserBadges :one
SELECT count(*)
FROM user_badges ub
JOIN badges b ON ub.badge_id = b.id
JOIN users u ON ub.user_id = u.id
WHERE (
    ? = '' OR
    b.title LIKE CONCAT('%', ?, '%') OR
    u.display_name LIKE CONCAT('%', ?, '%')
)
`

type CountAllUserBadgesParams struct {
	Search interface{} `json:"search"`
}

func (q *Queries) CountAllUserBadges(ctx context.Context, arg CountAllUserBadgesParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countAllUserBadges, arg.Search, arg.Search, arg.Search)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countAllUserMissions = `-- name: CountAllUserMissions :one
SELECT count(*)
FROM user_missions um
JOIN missions m ON um.mission_id = m.id
JOIN users u ON um.user_id = u.id
    WHERE (
    ? = '' OR
    m.title LIKE CONCAT('%', ?, '%') OR
    u.display_name LIKE CONCAT('%', ?, '%')
)
`

type CountAllUserMissionsParams struct {
	Search interface{} `json:"search"`
}

func (q *Queries) CountAllUserMissions(ctx context.Context, arg CountAllUserMissionsParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countAllUserMissions, arg.Search, arg.Search, arg.Search)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countBadges = `-- name: CountBadges :one
SELECT count(*) FROM badges
`

func (q *Queries) CountBadges(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countBadges)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createBadge = `-- name: CreateBadge :execresult

INSERT INTO badges (
    title, description, criteria
) VALUES (
    ?, ?, ?
)
`

type CreateBadgeParams struct {
	Title       string          `json:"title"`
	Description sql.NullString  `json:"description"`
	Criteria    json.RawMessage `json:"criteria"`
}

// Badges --
func (q *Queries) CreateBadge(ctx context.Context, arg CreateBadgeParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createBadge, arg.Title, arg.Description, arg.Criteria)
}

const createMission = `-- name: CreateMission :execresult

INSERT INTO missions (
    title, description, reward_points, metadata
) VALUES (
    ?, ?, ?, ?
)
`

type CreateMissionParams struct {
	Title        string          `json:"title"`
	Description  sql.NullString  `json:"description"`
	RewardPoints sql.NullInt32   `json:"reward_points"`
	Metadata     json.RawMessage `json:"metadata"`
}

// Missions --
func (q *Queries) CreateMission(ctx context.Context, arg CreateMissionParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createMission,
		arg.Title,
		arg.Description,
		arg.RewardPoints,
		arg.Metadata,
	)
}

const createPointsTransaction = `-- name: CreatePointsTransaction :execresult

INSERT INTO points_transactions (
    user_id, amount, reason, reference_type, reference_id
) VALUES (
    ?, ?, ?, ?, ?
)
`

type CreatePointsTransactionParams struct {
	UserID        int64          `json:"user_id"`
	Amount        int32          `json:"amount"`
	Reason        sql.NullString `json:"reason"`
	ReferenceType sql.NullString `json:"reference_type"`
	ReferenceID   sql.NullInt64  `json:"reference_id"`
}

// Points Transactions and Stats Helpers --
func (q *Queries) CreatePointsTransaction(ctx context.Context, arg CreatePointsTransactionParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createPointsTransaction,
		arg.UserID,
		arg.Amount,
		arg.Reason,
		arg.ReferenceType,
		arg.ReferenceID,
	)
}

const createUserMission = `-- name: CreateUserMission :execresult

INSERT INTO user_missions (
    mission_id, user_id, status, started_at, progress
) VALUES (
    ?, ?, ?, ?, ?
)
`

type CreateUserMissionParams struct {
	MissionID int64           `json:"mission_id"`
	UserID    int64           `json:"user_id"`
	Status    string          `json:"status"`
	StartedAt time.Time       `json:"started_at"`
	Progress  json.RawMessage `json:"progress"`
}

// User Missions --
func (q *Queries) CreateUserMission(ctx context.Context, arg CreateUserMissionParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createUserMission,
		arg.MissionID,
		arg.UserID,
		arg.Status,
		arg.StartedAt,
		arg.Progress,
	)
}

const deleteBadge = `-- name: DeleteBadge :exec
DELETE FROM badges
WHERE id = ?
`

func (q *Queries) DeleteBadge(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteBadge, id)
	return err
}

const deleteMission = `-- name: DeleteMission :exec
DELETE FROM missions
WHERE id = ?
`

func (q *Queries) DeleteMission(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteMission, id)
	return err
}

const deleteUserMission = `-- name: DeleteUserMission :exec
DELETE FROM user_missions
WHERE id = ?
`

func (q *Queries) DeleteUserMission(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteUserMission, id)
	return err
}

const getAllUserBadges = `-- name: GetAllUserBadges :many
SELECT
    ub.awarded_at,
    b.title AS badge_title,
    u.display_name AS user_name,
    u.email AS user_email
FROM user_badges ub
JOIN badges b ON ub.badge_id = b.id
JOIN users u ON ub.user_id = u.id
WHERE (
    ? = '' OR
    b.title LIKE CONCAT('%', ?, '%') OR
    u.display_name LIKE CONCAT('%', ?, '%')
)
ORDER BY ub.awarded_at DESC
LIMIT ? OFFSET ?
`

type GetAllUserBadgesParams struct {
	Search interface{} `json:"search"`
	Limit  int32       `json:"limit"`
	Offset int32       `json:"offset"`
}

type GetAllUserBadgesRow struct {
	AwardedAt  time.Time `json:"awarded_at"`
	BadgeTitle string    `json:"badge_title"`
	UserName   string    `json:"user_name"`
	UserEmail  string    `json:"user_email"`
}

func (q *Queries) GetAllUserBadges(ctx context.Context, arg GetAllUserBadgesParams) ([]GetAllUserBadgesRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllUserBadges,
		arg.Search,
		arg.Search,
		arg.Search,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllUserBadgesRow
	for rows.Next() {
		var i GetAllUserBadgesRow
		if err := rows.Scan(
			&i.AwardedAt,
			&i.BadgeTitle,
			&i.UserName,
			&i.UserEmail,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllUserMissions = `-- name: GetAllUserMissions :many
SELECT
    um.started_at,
    um.completed_at,
    um.status,
    m.title AS mission_title,
    u.display_name AS user_name,
    u.email AS user_email
FROM user_missions um
JOIN missions m ON um.mission_id = m.id
JOIN users u ON um.user_id = u.id
WHERE (
    ? = '' OR
    m.title LIKE CONCAT('%', ?, '%') OR
    u.display_name LIKE CONCAT('%', ?, '%')
)
ORDER BY um.started_at DESC
LIMIT ? OFFSET ?
`

type GetAllUserMissionsParams struct {
	Search interface{} `json:"search"`
	Limit  int32       `json:"limit"`
	Offset int32       `json:"offset"`
}

type GetAllUserMissionsRow struct {
	StartedAt    time.Time    `json:"started_at"`
	CompletedAt  sql.NullTime `json:"completed_at"`
	Status       string       `json:"status"`
	MissionTitle string       `json:"mission_title"`
	UserName     string       `json:"user_name"`
	UserEmail    string       `json:"user_email"`
}

func (q *Queries) GetAllUserMissions(ctx context.Context, arg GetAllUserMissionsParams) ([]GetAllUserMissionsRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllUserMissions,
		arg.Search,
		arg.Search,
		arg.Search,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllUserMissionsRow
	for rows.Next() {
		var i GetAllUserMissionsRow
		if err := rows.Scan(
			&i.StartedAt,
			&i.CompletedAt,
			&i.Status,
			&i.MissionTitle,
			&i.UserName,
			&i.UserEmail,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBadgeByID = `-- name: GetBadgeByID :one
SELECT id, title, description, criteria, created_at FROM badges
WHERE id = ?
`

func (q *Queries) GetBadgeByID(ctx context.Context, id int64) (Badge, error) {
	row := q.db.QueryRowContext(ctx, getBadgeByID, id)
	var i Badge
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.Criteria,
		&i.CreatedAt,
	)
	return i, err
}

const getBadges = `-- name: GetBadges :many
SELECT id, title, description, criteria, created_at FROM badges
ORDER BY created_at DESC
LIMIT ? OFFSET ?
`

type GetBadgesParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) GetBadges(ctx context.Context, arg GetBadgesParams) ([]Badge, error) {
	rows, err := q.db.QueryContext(ctx, getBadges, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Badge
	for rows.Next() {
		var i Badge
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.Criteria,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLeaderboard = `-- name: GetLeaderboard :many
SELECT 
    u.id, 
    u.display_name, 
    u.username, 
    up.avatar_url, 
    s.total_points
FROM user_stats s
JOIN users u ON s.user_id = u.id
LEFT JOIN user_profiles up ON u.id = up.user_id
ORDER BY s.total_points DESC
LIMIT ?
`

type GetLeaderboardRow struct {
	ID          int64          `json:"id"`
	DisplayName string         `json:"display_name"`
	Username    string         `json:"username"`
	AvatarUrl   sql.NullString `json:"avatar_url"`
	TotalPoints int64          `json:"total_points"`
}

func (q *Queries) GetLeaderboard(ctx context.Context, limit int32) ([]GetLeaderboardRow, error) {
	rows, err := q.db.QueryContext(ctx, getLeaderboard, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetLeaderboardRow
	for rows.Next() {
		var i GetLeaderboardRow
		if err := rows.Scan(
			&i.ID,
			&i.DisplayName,
			&i.Username,
			&i.AvatarUrl,
			&i.TotalPoints,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMissionByID = `-- name: GetMissionByID :one
SELECT id, title, description, reward_points, metadata, created_at, updated_at FROM missions
WHERE id = ?
`

func (q *Queries) GetMissionByID(ctx context.Context, id int64) (Mission, error) {
	row := q.db.QueryRowContext(ctx, getMissionByID, id)
	var i Mission
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.RewardPoints,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getMissions = `-- name: GetMissions :many
SELECT id, title, description, reward_points, metadata, created_at, updated_at FROM missions
ORDER BY created_at DESC
`

func (q *Queries) GetMissions(ctx context.Context) ([]Mission, error) {
	rows, err := q.db.QueryContext(ctx, getMissions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Mission
	for rows.Next() {
		var i Mission
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.RewardPoints,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserBadgesByUserID = `-- name: GetUserBadgesByUserID :many
SELECT ub.user_id, ub.badge_id, ub.awarded_at, b.title, b.description, b.criteria
FROM user_badges ub
JOIN badges b ON ub.badge_id = b.id
WHERE ub.user_id = ?
ORDER BY ub.awarded_at DESC
`

type GetUserBadgesByUserIDRow struct {
	UserID      int64           `json:"user_id"`
	BadgeID     int64           `json:"badge_id"`
	AwardedAt   time.Time       `json:"awarded_at"`
	Title       string          `json:"title"`
	Description sql.NullString  `json:"description"`
	Criteria    json.RawMessage `json:"criteria"`
}

func (q *Queries) GetUserBadgesByUserID(ctx context.Context, userID int64) ([]GetUserBadgesByUserIDRow, error) {
	rows, err := q.db.QueryContext(ctx, getUserBadgesByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserBadgesByUserIDRow
	for rows.Next() {
		var i GetUserBadgesByUserIDRow
		if err := rows.Scan(
			&i.UserID,
			&i.BadgeID,
			&i.AwardedAt,
			&i.Title,
			&i.Description,
			&i.Criteria,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserMissionByID = `-- name: GetUserMissionByID :one
SELECT um.id, um.mission_id, um.user_id, um.status, um.started_at, um.completed_at, um.progress,
       m.title, m.description, m.reward_points, m.metadata
FROM user_missions um
JOIN missions m ON um.mission_id = m.id
WHERE um.id = ?
`

type GetUserMissionByIDRow struct {
	ID           int64           `json:"id"`
	MissionID    int64           `json:"mission_id"`
	UserID       int64           `json:"user_id"`
	Status       string          `json:"status"`
	StartedAt    time.Time       `json:"started_at"`
	CompletedAt  sql.NullTime    `json:"completed_at"`
	Progress     json.RawMessage `json:"progress"`
	Title        string          `json:"title"`
	Description  sql.NullString  `json:"description"`
	RewardPoints sql.NullInt32   `json:"reward_points"`
	Metadata     json.RawMessage `json:"metadata"`
}

// Fetch single user mission with mission detail by ID
func (q *Queries) GetUserMissionByID(ctx context.Context, id int64) (GetUserMissionByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getUserMissionByID, id)
	var i GetUserMissionByIDRow
	err := row.Scan(
		&i.ID,
		&i.MissionID,
		&i.UserID,
		&i.Status,
		&i.StartedAt,
		&i.CompletedAt,
		&i.Progress,
		&i.Title,
		&i.Description,
		&i.RewardPoints,
		&i.Metadata,
	)
	return i, err
}

const getUserMissionByUserIDAndMissionID = `-- name: GetUserMissionByUserIDAndMissionID :one
SELECT id FROM user_missions
WHERE user_id = ? AND mission_id = ?
LIMIT 1
`

type GetUserMissionByUserIDAndMissionIDParams struct {
	UserID    int64 `json:"user_id"`
	MissionID int64 `json:"mission_id"`
}

func (q *Queries) GetUserMissionByUserIDAndMissionID(ctx context.Context, arg GetUserMissionByUserIDAndMissionIDParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, getUserMissionByUserIDAndMissionID, arg.UserID, arg.MissionID)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const getUserMissionsByUserID = `-- name: GetUserMissionsByUserID :many
SELECT um.id, um.mission_id, um.user_id, um.status, um.started_at, um.completed_at, um.progress, m.title, m.description, m.reward_points, m.metadata
FROM user_missions um
JOIN missions m ON um.mission_id = m.id
WHERE um.user_id = ?
ORDER BY um.started_at DESC
`

type GetUserMissionsByUserIDRow struct {
	ID           int64           `json:"id"`
	MissionID    int64           `json:"mission_id"`
	UserID       int64           `json:"user_id"`
	Status       string          `json:"status"`
	StartedAt    time.Time       `json:"started_at"`
	CompletedAt  sql.NullTime    `json:"completed_at"`
	Progress     json.RawMessage `json:"progress"`
	Title        string          `json:"title"`
	Description  sql.NullString  `json:"description"`
	RewardPoints sql.NullInt32   `json:"reward_points"`
	Metadata     json.RawMessage `json:"metadata"`
}

func (q *Queries) GetUserMissionsByUserID(ctx context.Context, userID int64) ([]GetUserMissionsByUserIDRow, error) {
	rows, err := q.db.QueryContext(ctx, getUserMissionsByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserMissionsByUserIDRow
	for rows.Next() {
		var i GetUserMissionsByUserIDRow
		if err := rows.Scan(
			&i.ID,
			&i.MissionID,
			&i.UserID,
			&i.Status,
			&i.StartedAt,
			&i.CompletedAt,
			&i.Progress,
			&i.Title,
			&i.Description,
			&i.RewardPoints,
			&i.Metadata,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserStats = `-- name: GetUserStats :one

SELECT user_id, total_points, updated_at FROM user_stats
WHERE user_id = ?
`

// User Stats --
func (q *Queries) GetUserStats(ctx context.Context, userID int64) (UserStat, error) {
	row := q.db.QueryRowContext(ctx, getUserStats, userID)
	var i UserStat
	err := row.Scan(&i.UserID, &i.TotalPoints, &i.UpdatedAt)
	return i, err
}

const initUserStatsIfMissing = `-- name: InitUserStatsIfMissing :exec
INSERT INTO user_stats (user_id, total_points, updated_at)
VALUES (?, 0, CURRENT_TIMESTAMP)
ON DUPLICATE KEY UPDATE user_id = user_id
`

func (q *Queries) InitUserStatsIfMissing(ctx context.Context, userID int64) error {
	_, err := q.db.ExecContext(ctx, initUserStatsIfMissing, userID)
	return err
}

const listPointsTransactionsByUserID = `-- name: ListPointsTransactionsByUserID :many
SELECT id, user_id, amount, reason, reference_type, reference_id, created_at
FROM points_transactions
WHERE user_id = ?
ORDER BY created_at DESC, id DESC
LIMIT ? OFFSET ?
`

type ListPointsTransactionsByUserIDParams struct {
	UserID int64 `json:"user_id"`
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListPointsTransactionsByUserID(ctx context.Context, arg ListPointsTransactionsByUserIDParams) ([]PointsTransaction, error) {
	rows, err := q.db.QueryContext(ctx, listPointsTransactionsByUserID, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PointsTransaction
	for rows.Next() {
		var i PointsTransaction
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Amount,
			&i.Reason,
			&i.ReferenceType,
			&i.ReferenceID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const revokeBadgeFromUser = `-- name: RevokeBadgeFromUser :exec
DELETE FROM user_badges
WHERE user_id = ? AND badge_id = ?
`

type RevokeBadgeFromUserParams struct {
	UserID  int64 `json:"user_id"`
	BadgeID int64 `json:"badge_id"`
}

func (q *Queries) RevokeBadgeFromUser(ctx context.Context, arg RevokeBadgeFromUserParams) error {
	_, err := q.db.ExecContext(ctx, revokeBadgeFromUser, arg.UserID, arg.BadgeID)
	return err
}

const updateBadge = `-- name: UpdateBadge :exec
UPDATE badges
SET
    title = ?,
    description = ?,
    criteria = ?
WHERE id = ?
`

type UpdateBadgeParams struct {
	Title       string          `json:"title"`
	Description sql.NullString  `json:"description"`
	Criteria    json.RawMessage `json:"criteria"`
	ID          int64           `json:"id"`
}

func (q *Queries) UpdateBadge(ctx context.Context, arg UpdateBadgeParams) error {
	_, err := q.db.ExecContext(ctx, updateBadge,
		arg.Title,
		arg.Description,
		arg.Criteria,
		arg.ID,
	)
	return err
}

const updateMission = `-- name: UpdateMission :exec
UPDATE missions
SET
    title = ?,
    description = ?,
    reward_points = ?,
    metadata = ?
WHERE id = ?
`

type UpdateMissionParams struct {
	Title        string          `json:"title"`
	Description  sql.NullString  `json:"description"`
	RewardPoints sql.NullInt32   `json:"reward_points"`
	Metadata     json.RawMessage `json:"metadata"`
	ID           int64           `json:"id"`
}

func (q *Queries) UpdateMission(ctx context.Context, arg UpdateMissionParams) error {
	_, err := q.db.ExecContext(ctx, updateMission,
		arg.Title,
		arg.Description,
		arg.RewardPoints,
		arg.Metadata,
		arg.ID,
	)
	return err
}

const updateUserMissionStatus = `-- name: UpdateUserMissionStatus :exec
UPDATE user_missions
SET
    status = ?,
    completed_at = ? -- Set to current timestamp if status is 'completed'
WHERE id = ?
`

type UpdateUserMissionStatusParams struct {
	Status      string       `json:"status"`
	CompletedAt sql.NullTime `json:"completed_at"`
	ID          int64        `json:"id"`
}

func (q *Queries) UpdateUserMissionStatus(ctx context.Context, arg UpdateUserMissionStatusParams) error {
	_, err := q.db.ExecContext(ctx, updateUserMissionStatus, arg.Status, arg.CompletedAt, arg.ID)
	return err
}

const updateUserStatsPoints = `-- name: UpdateUserStatsPoints :exec
UPDATE user_stats
SET
    total_points = ?
WHERE user_id = ?
`

type UpdateUserStatsPointsParams struct {
	TotalPoints int64 `json:"total_points"`
	UserID      int64 `json:"user_id"`
}

func (q *Queries) UpdateUserStatsPoints(ctx context.Context, arg UpdateUserStatsPointsParams) error {
	_, err := q.db.ExecContext(ctx, updateUserStatsPoints, arg.TotalPoints, arg.UserID)
	return err
}
