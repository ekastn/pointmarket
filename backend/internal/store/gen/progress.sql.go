// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: progress.sql

package gen

import (
	"context"
	"database/sql"
	"encoding/json"
	"time"
)

const createTextAnalysisSnapshot = `-- name: CreateTextAnalysisSnapshot :exec
INSERT INTO text_analysis_snapshots (
    student_id,
    original_text,
	average_word_length,
	reading_time,
    count_words,
    count_sentences,
    score_total,
    score_grammar,
    score_structure,
    score_readability,
    score_sentiment,
    score_complexity,
    learning_preference_type,
    learning_preference_label,
    learning_preference_combined_vark
) VALUES ( (SELECT student_id FROM students WHERE user_id = ?), ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ? )
`

type CreateTextAnalysisSnapshotParams struct {
	UserID                         int64           `json:"user_id"`
	OriginalText                   string          `json:"original_text"`
	AverageWordLength              float64         `json:"average_word_length"`
	ReadingTime                    int32           `json:"reading_time"`
	CountWords                     int32           `json:"count_words"`
	CountSentences                 int32           `json:"count_sentences"`
	ScoreTotal                     float64         `json:"score_total"`
	ScoreGrammar                   float64         `json:"score_grammar"`
	ScoreStructure                 float64         `json:"score_structure"`
	ScoreReadability               float64         `json:"score_readability"`
	ScoreSentiment                 float64         `json:"score_sentiment"`
	ScoreComplexity                float64         `json:"score_complexity"`
	LearningPreferenceType         string          `json:"learning_preference_type"`
	LearningPreferenceLabel        string          `json:"learning_preference_label"`
	LearningPreferenceCombinedVark json.RawMessage `json:"learning_preference_combined_vark"`
}

func (q *Queries) CreateTextAnalysisSnapshot(ctx context.Context, arg CreateTextAnalysisSnapshotParams) error {
	_, err := q.db.ExecContext(ctx, createTextAnalysisSnapshot,
		arg.UserID,
		arg.OriginalText,
		arg.AverageWordLength,
		arg.ReadingTime,
		arg.CountWords,
		arg.CountSentences,
		arg.ScoreTotal,
		arg.ScoreGrammar,
		arg.ScoreStructure,
		arg.ScoreReadability,
		arg.ScoreSentiment,
		arg.ScoreComplexity,
		arg.LearningPreferenceType,
		arg.LearningPreferenceLabel,
		arg.LearningPreferenceCombinedVark,
	)
	return err
}

const createWeeklyEvaluation = `-- name: CreateWeeklyEvaluation :exec
INSERT INTO weekly_evaluations
  (student_id, questionnaire_id, status, due_date)
VALUES ((SELECT student_id FROM students WHERE user_id = ?), ?, ?, ?)
`

type CreateWeeklyEvaluationParams struct {
	UserID          int64                   `json:"user_id"`
	QuestionnaireID int32                   `json:"questionnaire_id"`
	Status          WeeklyEvaluationsStatus `json:"status"`
	DueDate         time.Time               `json:"due_date"`
}

func (q *Queries) CreateWeeklyEvaluation(ctx context.Context, arg CreateWeeklyEvaluationParams) error {
	_, err := q.db.ExecContext(ctx, createWeeklyEvaluation,
		arg.UserID,
		arg.QuestionnaireID,
		arg.Status,
		arg.DueDate,
	)
	return err
}

const getWeeklyEvaluationByStudentAndQuestionnaireAndDueDate = `-- name: GetWeeklyEvaluationByStudentAndQuestionnaireAndDueDate :one
SELECT id FROM weekly_evaluations
WHERE student_id = (SELECT student_id FROM students WHERE user_id = ?) AND questionnaire_id = ? AND due_date = ?
`

type GetWeeklyEvaluationByStudentAndQuestionnaireAndDueDateParams struct {
	UserID          int64     `json:"user_id"`
	QuestionnaireID int32     `json:"questionnaire_id"`
	DueDate         time.Time `json:"due_date"`
}

func (q *Queries) GetWeeklyEvaluationByStudentAndQuestionnaireAndDueDate(ctx context.Context, arg GetWeeklyEvaluationByStudentAndQuestionnaireAndDueDateParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, getWeeklyEvaluationByStudentAndQuestionnaireAndDueDate, arg.UserID, arg.QuestionnaireID, arg.DueDate)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const getWeeklyEvaluationResult = `-- name: GetWeeklyEvaluationResult :one
SELECT
    sqr.total_score AS score,
    sqr.created_at AS completed_at
FROM
    student_questionnaire_likert_results sqr
WHERE
    sqr.weekly_evaluation_id = ?
`

type GetWeeklyEvaluationResultRow struct {
	Score       float64      `json:"score"`
	CompletedAt sql.NullTime `json:"completed_at"`
}

func (q *Queries) GetWeeklyEvaluationResult(ctx context.Context, weeklyEvaluationID sql.NullInt64) (GetWeeklyEvaluationResultRow, error) {
	row := q.db.QueryRowContext(ctx, getWeeklyEvaluationResult, weeklyEvaluationID)
	var i GetWeeklyEvaluationResultRow
	err := row.Scan(&i.Score, &i.CompletedAt)
	return i, err
}

const getWeeklyEvaluationsByStudentID = `-- name: GetWeeklyEvaluationsByStudentID :many
SELECT
    we.id,
    we.student_id,
    we.questionnaire_id,
    we.status,
    we.due_date,
    we.completed_at,
    q.name AS questionnaire_title,
    q.type AS questionnaire_type,
    q.description AS questionnaire_description
FROM
    weekly_evaluations we
JOIN
    questionnaires q ON we.questionnaire_id = q.id
WHERE
    we.student_id = (SELECT student_id FROM students WHERE user_id = ?) AND we.due_date >= DATE_SUB(CURDATE(), INTERVAL ? WEEK)
ORDER BY
    we.due_date DESC
`

type GetWeeklyEvaluationsByStudentIDParams struct {
	UserID  int64       `json:"user_id"`
	DATESUB interface{} `json:"DATE_SUB"`
}

type GetWeeklyEvaluationsByStudentIDRow struct {
	ID                       int64                   `json:"id"`
	StudentID                string                  `json:"student_id"`
	QuestionnaireID          int32                   `json:"questionnaire_id"`
	Status                   WeeklyEvaluationsStatus `json:"status"`
	DueDate                  time.Time               `json:"due_date"`
	CompletedAt              sql.NullTime            `json:"completed_at"`
	QuestionnaireTitle       string                  `json:"questionnaire_title"`
	QuestionnaireType        QuestionnairesType      `json:"questionnaire_type"`
	QuestionnaireDescription sql.NullString          `json:"questionnaire_description"`
}

func (q *Queries) GetWeeklyEvaluationsByStudentID(ctx context.Context, arg GetWeeklyEvaluationsByStudentIDParams) ([]GetWeeklyEvaluationsByStudentIDRow, error) {
	rows, err := q.db.QueryContext(ctx, getWeeklyEvaluationsByStudentID, arg.UserID, arg.DATESUB)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetWeeklyEvaluationsByStudentIDRow
	for rows.Next() {
		var i GetWeeklyEvaluationsByStudentIDRow
		if err := rows.Scan(
			&i.ID,
			&i.StudentID,
			&i.QuestionnaireID,
			&i.Status,
			&i.DueDate,
			&i.CompletedAt,
			&i.QuestionnaireTitle,
			&i.QuestionnaireType,
			&i.QuestionnaireDescription,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWeeklyEvaluationsForTeacherDashboard = `-- name: GetWeeklyEvaluationsForTeacherDashboard :many
SELECT
    u.id as student_id,
    u.display_name as student_name,
    COUNT(CASE WHEN we.status = 'completed' THEN 1 END) AS completed_count,
    COUNT(CASE WHEN we.status = 'pending' THEN 1 END) AS pending_count,
    COUNT(CASE WHEN we.status = 'overdue' THEN 1 END) AS overdue_count
FROM users u
JOIN students s ON u.id = s.user_id
LEFT JOIN weekly_evaluations we ON s.student_id = we.student_id AND we.due_date >= DATE_SUB(CURDATE(), INTERVAL ? WEEK)
WHERE u.role = 'siswa'
GROUP BY u.id, u.display_name
`

type GetWeeklyEvaluationsForTeacherDashboardRow struct {
	StudentID      int64  `json:"student_id"`
	StudentName    string `json:"student_name"`
	CompletedCount int64  `json:"completed_count"`
	PendingCount   int64  `json:"pending_count"`
	OverdueCount   int64  `json:"overdue_count"`
}

func (q *Queries) GetWeeklyEvaluationsForTeacherDashboard(ctx context.Context, dateSUB interface{}) ([]GetWeeklyEvaluationsForTeacherDashboardRow, error) {
	rows, err := q.db.QueryContext(ctx, getWeeklyEvaluationsForTeacherDashboard, dateSUB)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetWeeklyEvaluationsForTeacherDashboardRow
	for rows.Next() {
		var i GetWeeklyEvaluationsForTeacherDashboardRow
		if err := rows.Scan(
			&i.StudentID,
			&i.StudentName,
			&i.CompletedCount,
			&i.PendingCount,
			&i.OverdueCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markOverdueWeeklyEvaluations = `-- name: MarkOverdueWeeklyEvaluations :exec
UPDATE weekly_evaluations
SET status = 'overdue'
WHERE status = 'pending' AND due_date < NOW()
`

func (q *Queries) MarkOverdueWeeklyEvaluations(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, markOverdueWeeklyEvaluations)
	return err
}

const updateWeeklyEvaluationStatus = `-- name: UpdateWeeklyEvaluationStatus :exec
UPDATE weekly_evaluations
SET status = 'completed', completed_at = NOW()
WHERE id = ? AND student_id = (SELECT student_id FROM students WHERE user_id = ?)
`

type UpdateWeeklyEvaluationStatusParams struct {
	ID     int64 `json:"id"`
	UserID int64 `json:"user_id"`
}

func (q *Queries) UpdateWeeklyEvaluationStatus(ctx context.Context, arg UpdateWeeklyEvaluationStatusParams) error {
	_, err := q.db.ExecContext(ctx, updateWeeklyEvaluationStatus, arg.ID, arg.UserID)
	return err
}
