// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: questionnaire.sql

package gen

import (
	"context"
	"database/sql"
	"encoding/json"
)

const createLikertResult = `-- name: CreateLikertResult :exec
INSERT INTO student_questionnaire_likert_results
  (student_id, questionnaire_id, answers, total_score, subscale_scores, weekly_evaluation_id)
VALUES ((SELECT student_id FROM students WHERE user_id = ?), ?, ?, ?, ?, ?)
`

type CreateLikertResultParams struct {
	UserID             int64           `json:"user_id"`
	QuestionnaireID    int32           `json:"questionnaire_id"`
	Answers            json.RawMessage `json:"answers"`
	TotalScore         float64         `json:"total_score"`
	SubscaleScores     json.RawMessage `json:"subscale_scores"`
	WeeklyEvaluationID sql.NullInt64   `json:"weekly_evaluation_id"`
}

func (q *Queries) CreateLikertResult(ctx context.Context, arg CreateLikertResultParams) error {
	_, err := q.db.ExecContext(ctx, createLikertResult,
		arg.UserID,
		arg.QuestionnaireID,
		arg.Answers,
		arg.TotalScore,
		arg.SubscaleScores,
		arg.WeeklyEvaluationID,
	)
	return err
}

const createQuestion = `-- name: CreateQuestion :execresult
INSERT INTO questionnaire_questions (questionnaire_id, question_number, question_text, subscale)
VALUES (?, ?, ?, ?)
`

type CreateQuestionParams struct {
	QuestionnaireID int32          `json:"questionnaire_id"`
	QuestionNumber  int32          `json:"question_number"`
	QuestionText    string         `json:"question_text"`
	Subscale        sql.NullString `json:"subscale"`
}

func (q *Queries) CreateQuestion(ctx context.Context, arg CreateQuestionParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createQuestion,
		arg.QuestionnaireID,
		arg.QuestionNumber,
		arg.QuestionText,
		arg.Subscale,
	)
}

const createQuestionnaire = `-- name: CreateQuestionnaire :execresult
INSERT INTO questionnaires (type, name, description, total_questions, status)
VALUES (?, ?, ?, ?, ?)
`

type CreateQuestionnaireParams struct {
	Type           QuestionnairesType       `json:"type"`
	Name           string                   `json:"name"`
	Description    sql.NullString           `json:"description"`
	TotalQuestions int32                    `json:"total_questions"`
	Status         NullQuestionnairesStatus `json:"status"`
}

func (q *Queries) CreateQuestionnaire(ctx context.Context, arg CreateQuestionnaireParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createQuestionnaire,
		arg.Type,
		arg.Name,
		arg.Description,
		arg.TotalQuestions,
		arg.Status,
	)
}

const createVarkOption = `-- name: CreateVarkOption :execresult
INSERT INTO questionnaire_vark_options (question_id, option_text, option_letter, learning_style)
VALUES (?, ?, ?, ?)
`

type CreateVarkOptionParams struct {
	QuestionID    int32                                 `json:"question_id"`
	OptionText    string                                `json:"option_text"`
	OptionLetter  string                                `json:"option_letter"`
	LearningStyle QuestionnaireVarkOptionsLearningStyle `json:"learning_style"`
}

func (q *Queries) CreateVarkOption(ctx context.Context, arg CreateVarkOptionParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createVarkOption,
		arg.QuestionID,
		arg.OptionText,
		arg.OptionLetter,
		arg.LearningStyle,
	)
}

const createVarkResult = `-- name: CreateVarkResult :exec
INSERT INTO student_questionnaire_vark_results
  (student_id, questionnaire_id, vark_type, vark_label, score_visual, score_auditory, score_reading, score_kinesthetic, answers)
VALUES ((SELECT student_id FROM students WHERE user_id = ?), ?, ?, ?, ?, ?, ?, ?, ?)
`

type CreateVarkResultParams struct {
	UserID           int64                                   `json:"user_id"`
	QuestionnaireID  int32                                   `json:"questionnaire_id"`
	VarkType         StudentQuestionnaireVarkResultsVarkType `json:"vark_type"`
	VarkLabel        string                                  `json:"vark_label"`
	ScoreVisual      int32                                   `json:"score_visual"`
	ScoreAuditory    int32                                   `json:"score_auditory"`
	ScoreReading     int32                                   `json:"score_reading"`
	ScoreKinesthetic int32                                   `json:"score_kinesthetic"`
	Answers          json.RawMessage                         `json:"answers"`
}

func (q *Queries) CreateVarkResult(ctx context.Context, arg CreateVarkResultParams) error {
	_, err := q.db.ExecContext(ctx, createVarkResult,
		arg.UserID,
		arg.QuestionnaireID,
		arg.VarkType,
		arg.VarkLabel,
		arg.ScoreVisual,
		arg.ScoreAuditory,
		arg.ScoreReading,
		arg.ScoreKinesthetic,
		arg.Answers,
	)
	return err
}

const deleteQuestion = `-- name: DeleteQuestion :exec
DELETE FROM questionnaire_questions
WHERE id = ?
`

func (q *Queries) DeleteQuestion(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, deleteQuestion, id)
	return err
}

const deleteQuestionnaire = `-- name: DeleteQuestionnaire :exec
DELETE FROM questionnaires
WHERE id = ?
`

func (q *Queries) DeleteQuestionnaire(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, deleteQuestionnaire, id)
	return err
}

const deleteVarkOption = `-- name: DeleteVarkOption :exec
DELETE FROM questionnaire_vark_options
WHERE id = ?
`

func (q *Queries) DeleteVarkOption(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, deleteVarkOption, id)
	return err
}

const getActiveQuestionnaires = `-- name: GetActiveQuestionnaires :many
SELECT id, type, name, description, total_questions, status, created_at, updated_at
FROM questionnaires
WHERE status = 'active'
ORDER BY type, id
`

func (q *Queries) GetActiveQuestionnaires(ctx context.Context) ([]Questionnaire, error) {
	rows, err := q.db.QueryContext(ctx, getActiveQuestionnaires)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Questionnaire
	for rows.Next() {
		var i Questionnaire
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.Name,
			&i.Description,
			&i.TotalQuestions,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLatestLikertResultByType = `-- name: GetLatestLikertResultByType :one
SELECT r.id, r.student_id, r.questionnaire_id, r.answers, r.total_score, r.subscale_scores, r.created_at, r.weekly_evaluation_id
FROM student_questionnaire_likert_results r
JOIN questionnaires q ON r.questionnaire_id = q.id
WHERE r.student_id = (SELECT student_id FROM students WHERE user_id = ?) AND q.type = ?
ORDER BY r.created_at DESC
LIMIT 1
`

type GetLatestLikertResultByTypeParams struct {
	UserID int64              `json:"user_id"`
	Type   QuestionnairesType `json:"type"`
}

func (q *Queries) GetLatestLikertResultByType(ctx context.Context, arg GetLatestLikertResultByTypeParams) (StudentQuestionnaireLikertResult, error) {
	row := q.db.QueryRowContext(ctx, getLatestLikertResultByType, arg.UserID, arg.Type)
	var i StudentQuestionnaireLikertResult
	err := row.Scan(
		&i.ID,
		&i.StudentID,
		&i.QuestionnaireID,
		&i.Answers,
		&i.TotalScore,
		&i.SubscaleScores,
		&i.CreatedAt,
		&i.WeeklyEvaluationID,
	)
	return i, err
}

const getLatestVarkResult = `-- name: GetLatestVarkResult :one
SELECT r.id, r.student_id, r.questionnaire_id, r.score_visual, r.score_auditory, r.score_reading, r.score_kinesthetic, r.answers, r.created_at
FROM student_questionnaire_vark_results r
WHERE r.student_id = (SELECT student_id FROM students WHERE user_id = ?)
ORDER BY r.created_at DESC
LIMIT 1
`

type GetLatestVarkResultRow struct {
	ID               int64           `json:"id"`
	StudentID        string          `json:"student_id"`
	QuestionnaireID  int32           `json:"questionnaire_id"`
	ScoreVisual      int32           `json:"score_visual"`
	ScoreAuditory    int32           `json:"score_auditory"`
	ScoreReading     int32           `json:"score_reading"`
	ScoreKinesthetic int32           `json:"score_kinesthetic"`
	Answers          json.RawMessage `json:"answers"`
	CreatedAt        sql.NullTime    `json:"created_at"`
}

func (q *Queries) GetLatestVarkResult(ctx context.Context, userID int64) (GetLatestVarkResultRow, error) {
	row := q.db.QueryRowContext(ctx, getLatestVarkResult, userID)
	var i GetLatestVarkResultRow
	err := row.Scan(
		&i.ID,
		&i.StudentID,
		&i.QuestionnaireID,
		&i.ScoreVisual,
		&i.ScoreAuditory,
		&i.ScoreReading,
		&i.ScoreKinesthetic,
		&i.Answers,
		&i.CreatedAt,
	)
	return i, err
}

const getLikertStatsByStudent = `-- name: GetLikertStatsByStudent :many
SELECT q.id AS questionnaire_id, q.type, q.name,
       COUNT(r.id) AS attempts,
       AVG(r.total_score) AS average_score,
       MAX(r.total_score) AS best_score,
       MIN(r.total_score) AS lowest_score
FROM questionnaires q
LEFT JOIN student_questionnaire_likert_results r
  ON q.id = r.questionnaire_id AND r.student_id = (SELECT student_id FROM students WHERE user_id = ?)
WHERE q.type IN ('MSLQ','AMS') AND q.status='active'
GROUP BY q.id, q.type, q.name
ORDER BY q.type
`

type GetLikertStatsByStudentRow struct {
	QuestionnaireID int32              `json:"questionnaire_id"`
	Type            QuestionnairesType `json:"type"`
	Name            string             `json:"name"`
	Attempts        int64              `json:"attempts"`
	AverageScore    interface{}        `json:"average_score"`
	BestScore       interface{}        `json:"best_score"`
	LowestScore     interface{}        `json:"lowest_score"`
}

func (q *Queries) GetLikertStatsByStudent(ctx context.Context, userID int64) ([]GetLikertStatsByStudentRow, error) {
	rows, err := q.db.QueryContext(ctx, getLikertStatsByStudent, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetLikertStatsByStudentRow
	for rows.Next() {
		var i GetLikertStatsByStudentRow
		if err := rows.Scan(
			&i.QuestionnaireID,
			&i.Type,
			&i.Name,
			&i.Attempts,
			&i.AverageScore,
			&i.BestScore,
			&i.LowestScore,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getQuestionnaireByID = `-- name: GetQuestionnaireByID :one
SELECT id, type, name, description, total_questions, status, created_at, updated_at
FROM questionnaires
WHERE id = ? LIMIT 1
`

func (q *Queries) GetQuestionnaireByID(ctx context.Context, id int32) (Questionnaire, error) {
	row := q.db.QueryRowContext(ctx, getQuestionnaireByID, id)
	var i Questionnaire
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.Name,
		&i.Description,
		&i.TotalQuestions,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getQuestionnaireByType = `-- name: GetQuestionnaireByType :one
SELECT id, type, name, description, total_questions, status, created_at, updated_at FROM questionnaires
WHERE type = ? AND status = 'active'
`

func (q *Queries) GetQuestionnaireByType(ctx context.Context, type_ QuestionnairesType) (Questionnaire, error) {
	row := q.db.QueryRowContext(ctx, getQuestionnaireByType, type_)
	var i Questionnaire
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.Name,
		&i.Description,
		&i.TotalQuestions,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getQuestionnaires = `-- name: GetQuestionnaires :many
SELECT id, type, name, description, total_questions, status, created_at, updated_at
FROM questionnaires
`

func (q *Queries) GetQuestionnaires(ctx context.Context) ([]Questionnaire, error) {
	rows, err := q.db.QueryContext(ctx, getQuestionnaires)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Questionnaire
	for rows.Next() {
		var i Questionnaire
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.Name,
			&i.Description,
			&i.TotalQuestions,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getQuestionsByQuestionnaireID = `-- name: GetQuestionsByQuestionnaireID :many
SELECT id, questionnaire_id, question_number, question_text, subscale, created_at, updated_at
FROM questionnaire_questions
WHERE questionnaire_id = ?
ORDER BY question_number
`

func (q *Queries) GetQuestionsByQuestionnaireID(ctx context.Context, questionnaireID int32) ([]QuestionnaireQuestion, error) {
	rows, err := q.db.QueryContext(ctx, getQuestionsByQuestionnaireID, questionnaireID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []QuestionnaireQuestion
	for rows.Next() {
		var i QuestionnaireQuestion
		if err := rows.Scan(
			&i.ID,
			&i.QuestionnaireID,
			&i.QuestionNumber,
			&i.QuestionText,
			&i.Subscale,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getVarkOptionsByQuestionnaireID = `-- name: GetVarkOptionsByQuestionnaireID :many
SELECT id, question_id, option_text, option_letter, learning_style, created_at, updated_at
FROM questionnaire_vark_options
WHERE question_id IN (
    SELECT id
    FROM questionnaire_questions
    WHERE questionnaire_id = ?
)
`

func (q *Queries) GetVarkOptionsByQuestionnaireID(ctx context.Context, questionnaireID int32) ([]QuestionnaireVarkOption, error) {
	rows, err := q.db.QueryContext(ctx, getVarkOptionsByQuestionnaireID, questionnaireID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []QuestionnaireVarkOption
	for rows.Next() {
		var i QuestionnaireVarkOption
		if err := rows.Scan(
			&i.ID,
			&i.QuestionID,
			&i.OptionText,
			&i.OptionLetter,
			&i.LearningStyle,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateQuestion = `-- name: UpdateQuestion :exec
UPDATE questionnaire_questions
SET
  question_number = ?,
  question_text = ?,
  subscale = ?
WHERE id = ?
`

type UpdateQuestionParams struct {
	QuestionNumber int32          `json:"question_number"`
	QuestionText   string         `json:"question_text"`
	Subscale       sql.NullString `json:"subscale"`
	ID             int32          `json:"id"`
}

func (q *Queries) UpdateQuestion(ctx context.Context, arg UpdateQuestionParams) error {
	_, err := q.db.ExecContext(ctx, updateQuestion,
		arg.QuestionNumber,
		arg.QuestionText,
		arg.Subscale,
		arg.ID,
	)
	return err
}

const updateQuestionnaire = `-- name: UpdateQuestionnaire :exec
UPDATE questionnaires
SET
  name = ?,
  description = ?,
  total_questions = ?,
  status = ?
WHERE id = ?
`

type UpdateQuestionnaireParams struct {
	Name           string                   `json:"name"`
	Description    sql.NullString           `json:"description"`
	TotalQuestions int32                    `json:"total_questions"`
	Status         NullQuestionnairesStatus `json:"status"`
	ID             int32                    `json:"id"`
}

func (q *Queries) UpdateQuestionnaire(ctx context.Context, arg UpdateQuestionnaireParams) error {
	_, err := q.db.ExecContext(ctx, updateQuestionnaire,
		arg.Name,
		arg.Description,
		arg.TotalQuestions,
		arg.Status,
		arg.ID,
	)
	return err
}

const updateVarkOption = `-- name: UpdateVarkOption :exec
UPDATE questionnaire_vark_options
SET
  option_text = ?,
  option_letter = ?,
  learning_style = ?
WHERE id = ?
`

type UpdateVarkOptionParams struct {
	OptionText    string                                `json:"option_text"`
	OptionLetter  string                                `json:"option_letter"`
	LearningStyle QuestionnaireVarkOptionsLearningStyle `json:"learning_style"`
	ID            int32                                 `json:"id"`
}

func (q *Queries) UpdateVarkOption(ctx context.Context, arg UpdateVarkOptionParams) error {
	_, err := q.db.ExecContext(ctx, updateVarkOption,
		arg.OptionText,
		arg.OptionLetter,
		arg.LearningStyle,
		arg.ID,
	)
	return err
}
