// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: students.sql

package gen

import (
	"context"
	"database/sql"
	"time"
)

const countStudents = `-- name: CountStudents :one
SELECT COUNT(*)
FROM students s
JOIN users u ON u.id = s.user_id
WHERE
  (u.display_name LIKE CONCAT('%', ?, '%')
   OR u.username LIKE CONCAT('%', ?, '%')
   OR u.email LIKE CONCAT('%', ?, '%')
   OR s.student_id LIKE CONCAT('%', ?, '%')
   OR ? = '')
  AND (s.program_id = ? OR ? IS NULL)
  AND (s.cohort_year = ? OR ? IS NULL)
  AND (s.status = ? OR ? = '')
`

type CountStudentsParams struct {
	Search     interface{}    `json:"search"`
	ProgramID  sql.NullInt64  `json:"program_id"`
	CohortYear sql.NullInt32  `json:"cohort_year"`
	Status     StudentsStatus `json:"status"`
}

func (q *Queries) CountStudents(ctx context.Context, arg CountStudentsParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countStudents,
		arg.Search,
		arg.Search,
		arg.Search,
		arg.Search,
		arg.Search,
		arg.ProgramID,
		arg.ProgramID,
		arg.CohortYear,
		arg.CohortYear,
		arg.Status,
		arg.Status,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getStudentAcademicScores = `-- name: GetStudentAcademicScores :many
SELECT sa.score
FROM student_assignments sa
JOIN students s ON sa.student_id = s.id
WHERE s.user_id = ? AND sa.status = 'graded' AND sa.score IS NOT NULL
UNION ALL
SELECT sq.score
FROM student_quizzes sq
JOIN students s ON sq.student_id = s.id
WHERE s.user_id = ? AND sq.status = 'graded' AND sq.score IS NOT NULL
`

type GetStudentAcademicScoresParams struct {
	UserID   int64 `json:"user_id"`
	UserID_2 int64 `json:"user_id_2"`
}

func (q *Queries) GetStudentAcademicScores(ctx context.Context, arg GetStudentAcademicScoresParams) ([]*float64, error) {
	rows, err := q.db.QueryContext(ctx, getStudentAcademicScores, arg.UserID, arg.UserID_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*float64
	for rows.Next() {
		var score *float64
		if err := rows.Scan(&score); err != nil {
			return nil, err
		}
		items = append(items, score)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStudentByStudentID = `-- name: GetStudentByStudentID :one
SELECT s.user_id,
       s.student_id,
       s.program_id,
       p.name AS program_name,
       s.cohort_year,
       s.status,
       s.birth_date,
       s.gender,
       s.phone,
       s.created_at,
       s.updated_at
FROM students s
JOIN programs p ON p.id = s.program_id
WHERE s.student_id = ?
`

type GetStudentByStudentIDRow struct {
	UserID      int64              `json:"user_id"`
	StudentID   string             `json:"student_id"`
	ProgramID   int64              `json:"program_id"`
	ProgramName string             `json:"program_name"`
	CohortYear  sql.NullInt32      `json:"cohort_year"`
	Status      StudentsStatus     `json:"status"`
	BirthDate   sql.NullTime       `json:"birth_date"`
	Gender      NullStudentsGender `json:"gender"`
	Phone       sql.NullString     `json:"phone"`
	CreatedAt   time.Time          `json:"created_at"`
	UpdatedAt   time.Time          `json:"updated_at"`
}

func (q *Queries) GetStudentByStudentID(ctx context.Context, studentID string) (GetStudentByStudentIDRow, error) {
	row := q.db.QueryRowContext(ctx, getStudentByStudentID, studentID)
	var i GetStudentByStudentIDRow
	err := row.Scan(
		&i.UserID,
		&i.StudentID,
		&i.ProgramID,
		&i.ProgramName,
		&i.CohortYear,
		&i.Status,
		&i.BirthDate,
		&i.Gender,
		&i.Phone,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getStudentByUserID = `-- name: GetStudentByUserID :one
SELECT s.user_id,
       s.student_id,
       s.program_id,
       p.name AS program_name,
       s.cohort_year,
       s.status,
       s.birth_date,
       s.gender,
       s.phone,
       s.created_at,
       s.updated_at,
       s.academic_score
FROM students s
JOIN programs p ON p.id = s.program_id
WHERE s.user_id = ?
`

type GetStudentByUserIDRow struct {
	UserID        int64              `json:"user_id"`
	StudentID     string             `json:"student_id"`
	ProgramID     int64              `json:"program_id"`
	ProgramName   string             `json:"program_name"`
	CohortYear    sql.NullInt32      `json:"cohort_year"`
	Status        StudentsStatus     `json:"status"`
	BirthDate     sql.NullTime       `json:"birth_date"`
	Gender        NullStudentsGender `json:"gender"`
	Phone         sql.NullString     `json:"phone"`
	CreatedAt     time.Time          `json:"created_at"`
	UpdatedAt     time.Time          `json:"updated_at"`
	AcademicScore float64            `json:"academic_score"`
}

func (q *Queries) GetStudentByUserID(ctx context.Context, userID int64) (GetStudentByUserIDRow, error) {
	row := q.db.QueryRowContext(ctx, getStudentByUserID, userID)
	var i GetStudentByUserIDRow
	err := row.Scan(
		&i.UserID,
		&i.StudentID,
		&i.ProgramID,
		&i.ProgramName,
		&i.CohortYear,
		&i.Status,
		&i.BirthDate,
		&i.Gender,
		&i.Phone,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.AcademicScore,
	)
	return i, err
}

const insertStudent = `-- name: InsertStudent :exec
INSERT INTO students (
  user_id, student_id, program_id, cohort_year, status, birth_date, gender, phone
) VALUES (?, ?, ?, ?, ?, ?, ?, ?)
`

type InsertStudentParams struct {
	UserID     int64              `json:"user_id"`
	StudentID  string             `json:"student_id"`
	ProgramID  int64              `json:"program_id"`
	CohortYear sql.NullInt32      `json:"cohort_year"`
	Status     StudentsStatus     `json:"status"`
	BirthDate  sql.NullTime       `json:"birth_date"`
	Gender     NullStudentsGender `json:"gender"`
	Phone      sql.NullString     `json:"phone"`
}

func (q *Queries) InsertStudent(ctx context.Context, arg InsertStudentParams) error {
	_, err := q.db.ExecContext(ctx, insertStudent,
		arg.UserID,
		arg.StudentID,
		arg.ProgramID,
		arg.CohortYear,
		arg.Status,
		arg.BirthDate,
		arg.Gender,
		arg.Phone,
	)
	return err
}

const listPrograms = `-- name: ListPrograms :many
SELECT id, name, faculty_id, created_at, updated_at
FROM programs
ORDER BY name ASC
`

func (q *Queries) ListPrograms(ctx context.Context) ([]Program, error) {
	rows, err := q.db.QueryContext(ctx, listPrograms)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Program
	for rows.Next() {
		var i Program
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.FacultyID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchStudents = `-- name: SearchStudents :many
SELECT
  u.id          AS user_id,
  u.display_name,
  u.email,
  s.student_id,
  s.program_id,
  p.name        AS program_name,
  s.cohort_year,
  s.status,
  s.created_at,
  s.updated_at
FROM students s
JOIN users u ON u.id = s.user_id
JOIN programs p ON p.id = s.program_id
WHERE
  (u.display_name LIKE CONCAT('%', ?, '%')
   OR u.username LIKE CONCAT('%', ?, '%')
   OR u.email LIKE CONCAT('%', ?, '%')
   OR s.student_id LIKE CONCAT('%', ?, '%')
   OR ? = '')
  AND (s.program_id = ? OR ? IS NULL)
  AND (s.cohort_year = ? OR ? IS NULL)
  AND (s.status = ? OR ? = '')
ORDER BY u.display_name ASC
LIMIT ? OFFSET ?
`

type SearchStudentsParams struct {
	Search     interface{}    `json:"search"`
	ProgramID  sql.NullInt64  `json:"program_id"`
	CohortYear sql.NullInt32  `json:"cohort_year"`
	Status     StudentsStatus `json:"status"`
	Limit      int32          `json:"limit"`
	Offset     int32          `json:"offset"`
}

type SearchStudentsRow struct {
	UserID      int64          `json:"user_id"`
	DisplayName string         `json:"display_name"`
	Email       string         `json:"email"`
	StudentID   string         `json:"student_id"`
	ProgramID   int64          `json:"program_id"`
	ProgramName string         `json:"program_name"`
	CohortYear  sql.NullInt32  `json:"cohort_year"`
	Status      StudentsStatus `json:"status"`
	CreatedAt   time.Time      `json:"created_at"`
	UpdatedAt   time.Time      `json:"updated_at"`
}

func (q *Queries) SearchStudents(ctx context.Context, arg SearchStudentsParams) ([]SearchStudentsRow, error) {
	rows, err := q.db.QueryContext(ctx, searchStudents,
		arg.Search,
		arg.Search,
		arg.Search,
		arg.Search,
		arg.Search,
		arg.ProgramID,
		arg.ProgramID,
		arg.CohortYear,
		arg.CohortYear,
		arg.Status,
		arg.Status,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchStudentsRow
	for rows.Next() {
		var i SearchStudentsRow
		if err := rows.Scan(
			&i.UserID,
			&i.DisplayName,
			&i.Email,
			&i.StudentID,
			&i.ProgramID,
			&i.ProgramName,
			&i.CohortYear,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateStudentAcademicScore = `-- name: UpdateStudentAcademicScore :exec
UPDATE students
SET academic_score = ?
WHERE user_id = ?
`

type UpdateStudentAcademicScoreParams struct {
	AcademicScore float64 `json:"academic_score"`
	UserID        int64   `json:"user_id"`
}

func (q *Queries) UpdateStudentAcademicScore(ctx context.Context, arg UpdateStudentAcademicScoreParams) error {
	_, err := q.db.ExecContext(ctx, updateStudentAcademicScore, arg.AcademicScore, arg.UserID)
	return err
}

const updateStudentByUserID = `-- name: UpdateStudentByUserID :exec
UPDATE students
SET student_id = ?,
    program_id = ?,
    cohort_year = ?,
    status = ?,
    birth_date = ?,
    gender = ?,
    phone = ?
WHERE user_id = ?
`

type UpdateStudentByUserIDParams struct {
	StudentID  string             `json:"student_id"`
	ProgramID  int64              `json:"program_id"`
	CohortYear sql.NullInt32      `json:"cohort_year"`
	Status     StudentsStatus     `json:"status"`
	BirthDate  sql.NullTime       `json:"birth_date"`
	Gender     NullStudentsGender `json:"gender"`
	Phone      sql.NullString     `json:"phone"`
	UserID     int64              `json:"user_id"`
}

func (q *Queries) UpdateStudentByUserID(ctx context.Context, arg UpdateStudentByUserIDParams) error {
	_, err := q.db.ExecContext(ctx, updateStudentByUserID,
		arg.StudentID,
		arg.ProgramID,
		arg.CohortYear,
		arg.Status,
		arg.BirthDate,
		arg.Gender,
		arg.Phone,
		arg.UserID,
	)
	return err
}
